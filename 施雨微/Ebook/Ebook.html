<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
	<style>
		body,html,div,p,input,span,a,h3{
			margin:0;
			padding:0;
		}
		html,body{
			height: 100%;
		}
		.content{
			width: 100%;
		}
		.main{
			width: 100%;
			/*background: #ffe483;*/
		}
		h3{
			text-align: center;
			padding:10px 0;
		}
		.adjust-items{
			width: 100%;
			height:100px;
			background: #b59f65;
			position: fixed;
			bottom:0;
		}
		.font{
			padding:5px 10px 0;
			overflow: hidden;
		}
		.font div{
			float: left;
			width: 40px;
			height: 40px;
			line-height: 40px;
			text-align: center;
			background: #ccc;
			margin-left:45px;
			border-radius: 10px;
		}
		.backgroundcolor{
			width: 100%;
			height: 50px;
			overflow: hidden;
			padding:5px 10px 0;
		}
		.backgroundcolor span{
			display: block;
			float: left;
			width: 40px;
			height: 40px;
			margin:0 10px;
		}
		.backgroundcolor span:first-child{
			background: #ffe483;
		}
		.backgroundcolor span:nth-child(2){
			background: lightgreen;
		}
		.backgroundcolor span:nth-child(3){
			background: #999;
		}
		.backgroundcolor span:nth-child(4){
			background: lightblue;
		}
		.backgroundcolor span:nth-child(5){
			background: pink;
		}
	</style>
</head>
<body>
	<div class="content">
		<div class="main js-main">
			<h3>蜀道难</h3>
			<div class="main-content js-main-content">
				&nbsp;&nbsp;&nbsp;&nbsp;噫吁嚱， 危乎高哉！ 蜀道之难， 难于上青天！ 蚕丛及鱼凫， 开国何茫然！ 尔来四万八千岁， 不与秦塞通人烟。 西当太白有鸟道， 可以横绝峨眉巅。 地崩山摧壮士死， 然后天梯石栈相钩连。 上有六龙回日之高标， 下有冲波逆折之回川。 黄鹤之飞尚不得过， 猿猱欲度愁攀援。 青泥何盘盘， 百步九折萦岩峦。 扪参历井仰胁息， 以手抚膺坐长叹。
				&nbsp;&nbsp;&nbsp;&nbsp;问君西游何时还？ 畏途巉岩不可攀。 但见悲鸟号古木， 雄飞雌从绕林间。 又闻子规啼夜月， 愁空山。 蜀道之难， 难于上青天， 使人听此凋朱颜！ 连峰去天不盈尺， 枯松倒挂倚绝壁。 飞湍瀑流争喧豗， 砯崖转石万壑雷。 其险也如此， 嗟尔远道之人胡为乎来哉！
				&nbsp;&nbsp;&nbsp;&nbsp;剑阁峥嵘而崔嵬， 一夫当关， 万夫莫开。 所守或匪亲， 化为狼与豺。 朝避猛虎， 夕避长蛇； 磨牙吮血， 杀人如麻。 锦城虽云乐， 不如早还家。 蜀道之难， 难于上青天， 侧身西望长咨嗟！
				&nbsp;&nbsp;&nbsp;&nbsp;因此我们可以在空函数中进行出队操作$(this).animate({width:300},2000).queue("fx",function(){$(this).dequeue("fx")}).animate({left:300},2000); 这时，把left从0变成300的函数就可以执行了。由于fx是队列中的默认名字，因此上面的代码，可以不用写fx，也就是可以这样写：$(this).animate({width:300},2000).queue(function(){$(this).dequeue()}).animate({left:300},2000);当然也可以这样写：$(this).animate({width:300},2000).queue(function(){next()}).animate({left:300},2000);next方法也是出队的意思。
				&nbsp;&nbsp;&nbsp;&nbsp;animate方法还有第三个参数，就是回调方法，比如：
				&nbsp;&nbsp;&nbsp;&nbsp;$(this).animate({width:300},2000,function(){}).animate({left:300},2000);当把div的宽度从100变成300时（2秒），就会执行function(){},在执行function里面的代码后，就会立即执行把left从0到300的函数。如果function(){}里面有一个定时器，比如：把高度从100变成300的定时器函数。这时就会出现高度和left同时变化的情况。
				&nbsp;&nbsp;&nbsp;&nbsp;由此可知animate的回调方法，不可控，意思就是它的回调方法执行后会立即执行后面的animate中添加的定时器函数。但是queue就不一样，它是可控的，我们可以等function函数执行完成后（也就是说把function里面的把高度从100变成300的定时器函数执行结束后），再调用next方法，这时它后面的animate添加的定时器函数才会执行，也就是进行出队，执行把left从0变成300的定时器函数。能很方便的控制异步操作的流程。
				&nbsp;&nbsp;&nbsp;&nbsp;我了解js模块是从立即执行函数开始的。但是等到真正使用构建工具的时候，却发现业界采用的模块化方案，却并非是一个一个由立即函数+闭包形成的集群。
				&nbsp;&nbsp;&nbsp;&nbsp;而是用了诸如AMD/CMD/CommonJS/ES6模块等等模块化实现。
				&nbsp;&nbsp;&nbsp;&nbsp;这里面的原因可能有这几个，一，闭包的性能问题。二，当模块增多的时候，需要解决模块间的依赖管理问题。
			</div>
		</div>
		<div class="adjust-items">
			<div class="font">
				<div class="bigFont js-bigFont">A+</div>
				<div class="nowFont js-nowFont">16</div>
				<div class="smallFont js-smallFont">A-</div>
			</div>
			<p class="backgroundcolor js-backgroundcolor">
				<span></span>
				<span></span>
				<span></span>
				<span></span>
				<span></span> 
			</p>	
		</div>
	</div>
	
	<script src="./jquery-1.11.3.js"></script>
	<script type='application/javascript' src='./fastclick.js'></script>
	<script>
	 $(function() {
	 	FastClick.attach(document.body);
	 	function Page() {

		}
		$.extend(Page.prototype, {
			init: function() {
				this.bindEvents();
			},

			bindEvents: function() {
				this.handleInitialFont();				
				this.handleClickFontChange();
				this.handleBackground();
				this.handleSelectColor();
			},

			handleInitialFont: function() {
				if(!window.localStorage.fontSize){
					window.localStorage.fontSize = 16;
				}
				this.fontSize = parseInt(window.localStorage.fontSize, 10);
				$(".js-nowFont").text(this.fontSize);
				$(".js-main-content").css("font-size", this.fontSize);				
			},

			handleClickFontChange: function() {				
				$(".js-bigFont").on("click", $.proxy(this.handleFontBig, this));
				$(".js-smallFont").on("click", $.proxy(this.handleFontSmall, this));
			},

			handleFontBig: function() {
				if(this.fontSize >= 32){
					this.fontSize = 32;
				}else{
					this.fontSize += 2;
				}
				$(".js-main-content").css("font-size", this.fontSize);
				$(".js-nowFont").text(this.fontSize);
				window.localStorage.fontSize = this.fontSize;
			},

			handleFontSmall: function() {
				if(this.fontSize <= 12){
					this.fontSize = 12;
				}else{
					this.fontSize -= 2;
				}	
				$(".js-main-content").css("font-size", this.fontSize);
				$(".js-nowFont").text(this.fontSize);
				window.localStorage.fontSize = this.fontSize;
			},

			handleBackground: function() {
				if(!window.localStorage.background){
					window.localStorage.background = "#ffe483";
				}
				this.background = window.localStorage.background;
				$(".js-main").css("background", this.background);
			},

			handleSelectColor: function() {
				$(".js-backgroundcolor").on("click", "span", $.proxy(this.handleBackgroundChange, this));				
			},

			handleBackgroundChange: function(e) {
				this.background = $(e.currentTarget).css("backgroundColor");
				$(".js-main").css("background", this.background);
				// console.log($(e.currentTarget).css("backgroundColor"))
				window.localStorage.background = this.background;
			}
		})
		var page = new Page();
		page.init();
	 })		
	</script>
</body>
</html>